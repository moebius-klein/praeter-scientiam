<!DOCTYPE html>
<html lang="la">

<head>
  <meta charset="UTF-8" />
  <title>CODEX Δ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Cinzel für Überschrift, Inter als Body-Font -->
  <link
    href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@300;400;500&display=swap"
    rel="stylesheet" />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #f5f5f5;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    canvas#starfield {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    .codex-layer {
      position: relative;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      opacity: 1;
      /* neu: für Zoom-Transition */
      transform-origin: center center;
      transform: scale(1);
    }

    /* alte Fade-Klassen – werden nicht mehr benutzt,
       können bleiben, falls du später nochmal reaktivieren willst */
    .codex-layer.fading-out {
      opacity: 0;
    }

    .codex-layer.fading-in {
      opacity: 1;
    }

    /* Zoom-Out / Zoom-In Animationen für den ganzen Layer */
    .codex-layer.is-transitioning {
      pointer-events: none;
      /* während der Transition keine neuen Klicks */
    }

    .codex-layer.zoom-out {
      animation: codexZoomOut 1.6s ease-in forwards;
    }

    .codex-layer.zoom-in {
      animation: codexZoomIn 1.6s ease-out forwards;
    }

    @keyframes codexZoomOut {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      100% {
        transform: scale(0.1);
        opacity: 0;
      }
    }

    @keyframes codexZoomIn {
      0% {
        transform: scale(0.1);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Überschrift: oben, zentriert, Konturschrift */
    .codex-title {
      position: absolute;
      top: 8vh;
      left: 50%;
      transform: translateX(-50%);
      font-family: "Cinzel", serif;
      font-size: clamp(1.4rem, 2.8vw, 2.8rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: transparent;
      -webkit-text-stroke: 1px #d4a950;
      text-shadow:
        0 0 15px rgba(212, 169, 80, 0.85),
        0 0 25px rgba(212, 169, 80, 0.35);
      white-space: nowrap;
      z-index: 2;
      pointer-events: none;
    }

    /* Knoten: zweizeilig, zentriert, nebelhaft-goldene Kartusche */
    .codex-node {
      position: absolute;
      font-size: 0.78rem;
      line-height: 1.25;
      color: #f2eee4;
      opacity: 0.97;
      white-space: normal;
      text-align: center;
      max-width: 12rem;

      padding: 0.4rem 1.0rem;
      border-radius: 999px;
      /* Oval / Pillenform */

      /* Grundton dunkel-golden */
      background-color: rgba(10, 7, 0, 0.92);

      /* Nebel + Licht + feiner Noise */
      background-image:
        radial-gradient(circle at 50% 30%, rgba(212, 169, 80, 0.28), transparent 60%),
        radial-gradient(circle at 80% 120%, rgba(0, 0, 0, 0.9), transparent 70%),
        repeating-linear-gradient(45deg,
          rgba(212, 169, 80, 0.09),
          rgba(212, 169, 80, 0.09) 1px,
          transparent 1px,
          transparent 3px),
        repeating-linear-gradient(-45deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.04) 1px,
          transparent 1px,
          transparent 4px);

      border: 1px solid rgba(212, 169, 80, 0.7);
      box-shadow:
        0 0 10px rgba(0, 0, 0, 0.95),
        0 0 14px rgba(212, 169, 80, 0.45),
        0 0 26px rgba(212, 169, 80, 0.22);

      pointer-events: none;
      z-index: 2;
    }

    .codex-node strong {
      display: block;
      font-family: "Cinzel", serif;
      letter-spacing: 0.14em;
      font-size: 0.82rem;
    }

    .codex-node span {
      display: block;
      font-size: 0.72rem;
      opacity: 0.92;
      margin-top: 0.12rem;
    }

    .codex-image {
      position: absolute;
      max-width: 50vw;
      max-height: 50vh;
      transform-origin: center center;
      image-rendering: auto;
      z-index: 1;
      filter: drop-shadow(0 0 18px rgba(212, 169, 80, 0.65));
      opacity: 0.9;
      pointer-events: none;
      /* Grundregel: Bilder nicht klickbar */
    }

    .codex-image.sigillum {
      opacity: 0.95;
      pointer-events: none;
      /* NEU: damit das <object> selbst keine Klicks frisst */
    }

    .codex-image.sprite {
      opacity: 0.9;
    }

    /* Slot-Machine: darf geklickt werden, leicht pulsierend */
    .codex-image.slotmachine {
      pointer-events: auto;
      cursor: pointer;
      animation: slotPulse 6s ease-in-out infinite;
    }

    @keyframes slotPulse {
      0% {
        opacity: 0.88;
        filter: drop-shadow(0 0 14px rgba(212, 169, 80, 0.45));
      }

      50% {
        opacity: 1;
        filter: drop-shadow(0 0 22px rgba(212, 169, 80, 0.75));
      }

      100% {
        opacity: 0.88;
        filter: drop-shadow(0 0 14px rgba(212, 169, 80, 0.45));
      }
    }

    .codex-image svg {
      width: 100%;
      height: auto;
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="starfield"></canvas>
  <div class="codex-layer" id="codex-layer"></div>

  <!-- JSON-Zustandsraum -->
  <script id="codex-config" type="application/json">
  {
    "title": "STRICTIO NOTATIONAE CODEX Δ",
    "sigillum": {
      "src": "sigillum_codex_delta_orbis.svg",
      "minScale": 0.55,
      "maxScale": 0.8,
      "minRotation": -8,
      "maxRotation": 8
    },
    "sprites": [
      {
        "id": "cerberus",
        "src": "cerberus_codex.png",
        "minScale": 0.5,
        "maxScale": 1.1,
        "minRotation": -25,
        "maxRotation": 25
      },
      {
        "id": "slotmachine",
        "src": "slotmachine_codex.png",
        "minScale": 0.3,
        "maxScale": 1.2,
        "minRotation": -20,
        "maxRotation": 20
      }
    ],
    "nodes": [
      {
        "id": "ordo",
        "label": "ORDO",
        "text": "ordo sine hierarchia"
      },
      {
        "id": "distinctio",
        "label": "DISTINCTIO",
        "text": "distinctio sine gradu"
      },
      {
        "id": "relatio",
        "label": "RELATIO",
        "text": "relatio sine centro"
      },
      {
        "id": "delta",
        "label": "Δ / !Δ",
        "text": "differentia minima / maxima"
      },
      {
        "id": "fundamenta",
        "label": "FUNDAMENTA",
        "text": "LP · TP · MP · EP"
      },
      {
        "id": "derivata",
        "label": "DERIVATA",
        "text": "m, e, ωᵢ, t_local"
      }
    ]
  }
  </script>

  <script>
    function randBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    function shuffle(array) {
      const a = array.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // -------- Starfield (Variante B – Einzel-Events) --------
    (function initStarfield() {
      const canvas = document.getElementById("starfield");
      const ctx = canvas.getContext("2d");
      let width = window.innerWidth;
      let height = window.innerHeight;

      // Kosmischer Mittelpunkt (an das Sigillum angepasst)
      let cx = width / 2;
      let cy = height * 0.55;

      let stars = [];
      let eventStars = [];
      let lastTime = 0;
      let nextEventSpawn = 0;

      const BASE_DENSITY = 8000; // je größer, desto weniger Sterne
      const STAR_PALETTE = [
        { r: 212, g: 169, b: 80 },  // warmes Gold
        { r: 158, g: 132, b: 82 },  // gedämpftes Gold
        { r: 125, g: 106, b: 64 },  // dunkles Bronze-Gold
        { r: 205, g: 213, b: 255 }  // kühles Blauweiß (selten)
      ];

      function chooseColor() {
        const t = Math.random();
        if (t < 0.55) return STAR_PALETTE[0];
        if (t < 0.80) return STAR_PALETTE[1];
        if (t < 0.95) return STAR_PALETTE[2];
        return STAR_PALETTE[3];
      }

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height * 0.55;
        createStars();
      }

      function createStars() {
        const count = Math.floor((width * height) / BASE_DENSITY);
        stars = [];
        for (let i = 0; i < count; i++) {
          const color = chooseColor();
          const still = Math.random() < 0.75; // 75 % quasi statisch
          stars.push({
            x: Math.random() * width,
            y: Math.random() * height,
            radius: randBetween(0.4, 1.3),
            color,
            radialSpeed: still ? randBetween(0.0, 0.015) : randBetween(0.015, 0.04),
            twinkleSpeed: randBetween(0.0015, 0.005),
            twinklePhase: Math.random() * Math.PI * 2
          });
        }
      }

      // EIN einzelner „Warp-Stern“ aus dem Mittenraum
      function spawnEventStar() {
        const angle = Math.random() * Math.PI * 2;
        const baseRadius = randBetween(5, 60); // näher am Zentrum
        const startX = cx + Math.cos(angle) * baseRadius;
        const startY = cy + Math.sin(angle) * baseRadius;

        const dx = startX - cx;
        const dy = startY - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const dirX = dx / dist;
        const dirY = dy / dist;

        eventStars.push({
          x: startX,
          y: startY,
          dirX,
          dirY,
          speed: randBetween(0.8, 2.0),      // deutlich langsamer
          life: 0,
          maxLife: randBetween(400, 800),    // lebt länger, fliegt ruhig raus
          radius: randBetween(0.9, 1.6),
          color: { r: 235, g: 205, b: 140 }
        });
      }

      function resetStar(star) {
        const color = chooseColor();
        star.x = Math.random() * width;
        star.y = Math.random() * height;
        star.radius = randBetween(0.4, 1.3);
        star.color = color;
        const still = Math.random() < 0.75;
        star.radialSpeed = still ? randBetween(0.0, 0.015) : randBetween(0.015, 0.04);
        star.twinkleSpeed = randBetween(0.0015, 0.005);
        star.twinklePhase = Math.random() * Math.PI * 2;
      }

      function draw(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 16.67; // ~frames
        lastTime = timestamp;

        // Hintergrund leicht übermalen, damit ein Hauch von Trail bleibt
        ctx.fillStyle = "rgba(0, 0, 0, 0.88)";
        ctx.fillRect(0, 0, width, height);

        // Normale Sterne
        for (const star of stars) {
          const dx = star.x - cx;
          const dy = star.y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          // sehr langsame radiale Bewegung
          star.x += (dx / dist) * star.radialSpeed * dt;
          star.y += (dy / dist) * star.radialSpeed * dt;

          // wenn außerhalb, neu setzen
          if (star.x < -10 || star.x > width + 10 || star.y < -10 || star.y > height + 10) {
            resetStar(star);
          }

          const twinkle =
            0.55 + 0.45 * Math.sin(star.twinklePhase + timestamp * star.twinkleSpeed);
          const radius = star.radius * (0.7 + 0.6 * twinkle);
          const alpha = 0.25 + 0.45 * twinkle;

          ctx.beginPath();
          ctx.arc(star.x, star.y, radius, 0, Math.PI * 2);
          ctx.fillStyle =
            "rgba(" +
            star.color.r + "," +
            star.color.g + "," +
            star.color.b + "," +
            alpha + ")";
          ctx.fill();
        }

        // Event-Stars (Warp-Effekte, jetzt EINZELN)
        for (let i = eventStars.length - 1; i >= 0; i--) {
          const es = eventStars[i];
          es.life += dt;
          es.x += es.dirX * es.speed * dt;
          es.y += es.dirY * es.speed * dt;

          const t = es.life / es.maxLife;
          const alpha = Math.max(0, 1 - t);
          const radius = es.radius * (1 + 0.4 * (1 - t));

          if (
            es.life >= es.maxLife ||
            es.x < -20 || es.x > width + 20 ||
            es.y < -20 || es.y > height + 20
          ) {
            eventStars.splice(i, 1);
            continue;
          }

          ctx.beginPath();
          ctx.arc(es.x, es.y, radius, 0, Math.PI * 2);
          ctx.fillStyle =
            "rgba(" +
            es.color.r + "," +
            es.color.g + "," +
            es.color.b + "," +
            (0.35 + 0.45 * alpha) + ")";
          ctx.fill();
        }

        // Unregelmäßige Einzel-Events (3.5–9 s Abstand)
        if (!nextEventSpawn) {
          nextEventSpawn = timestamp + randBetween(3500, 9000);
        }
        if (timestamp >= nextEventSpawn) {
          spawnEventStar();
          nextEventSpawn = timestamp + randBetween(3500, 9000);
        }

        requestAnimationFrame(draw);
      }

      window.addEventListener("resize", resize);
      resize();
      requestAnimationFrame(draw);
    })();

    // -------- Codex-Instanziierung + Re-Render --------
    (function initCodex() {
      const layer = document.getElementById("codex-layer");
      const configEl = document.getElementById("codex-config");
      const config = JSON.parse(configEl.textContent.trim());

      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const cx = vw / 2;
      const cy = vh * 0.55;
      const r = 0.32 * Math.min(vw, vh); // Kreisradius für die Knoten

      function clearLayer() {
        while (layer.firstChild) {
          layer.removeChild(layer.firstChild);
        }
      }

      // zentrale Zoom-Transition
      function zoomAndRerender() {
        if (layer.classList.contains("is-transitioning")) return;

        layer.classList.add("is-transitioning", "zoom-out");

        function onZoomOutEnd(e) {
          if (e.animationName !== "codexZoomOut") return;
          layer.removeEventListener("animationend", onZoomOutEnd);
          layer.classList.remove("zoom-out");

          clearLayer();
          renderOnce();

          layer.classList.add("zoom-in");

          function onZoomInEnd(ev) {
            if (ev.animationName !== "codexZoomIn") return;
            layer.removeEventListener("animationend", onZoomInEnd);
            layer.classList.remove("zoom-in", "is-transitioning");
          }

          layer.addEventListener("animationend", onZoomInEnd);
        }

        layer.addEventListener("animationend", onZoomOutEnd);
      }

      // gemeinsamer Trigger für Slot, Zerberus, Sigillum
      function attachCodexTrigger(el) {
        if (!el) return;
        el.style.pointerEvents = "auto";
        el.style.cursor = "pointer";

        el.addEventListener("click", () => {
          // kurzer Flash
          el.style.transition = "filter 150ms ease-out";
          el.style.filter = "drop-shadow(0 0 26px rgba(255, 230, 150, 0.95))";
          setTimeout(() => {
            el.style.filter = "";
          }, 160);

          zoomAndRerender();
        });
      }

      function renderOnce() {
        // Überschrift
        const titleEl = document.createElement("div");
        titleEl.className = "codex-title";
        titleEl.textContent = config.title || "CODEX Δ";
        layer.appendChild(titleEl);

        // Sigillum: exakt zentriert, konzentrisch zum Knoten-Kreis
        if (config.sigillum && config.sigillum.src) {
          const obj = document.createElement("object");
          obj.className = "codex-image sigillum";
          obj.type = "image/svg+xml";
          obj.data = config.sigillum.src;
          obj.setAttribute("aria-label", "Sigillum Codex Δ");
          layer.appendChild(obj);

          obj.addEventListener("load", () => {
            const scale = randBetween(config.sigillum.minScale, config.sigillum.maxScale);
            const rotation = randBetween(config.sigillum.minRotation, config.sigillum.maxRotation);

            // Sigillum selbst positionieren (nur visuell, nicht klickbar)
            obj.style.left = cx + "px";
            obj.style.top = cy + "px";
            obj.style.transform =
              "translate(-50%, -50%) scale(" + scale + ") rotate(" + rotation + "deg)";
            obj.style.pointerEvents = "none";

            // Unsichtbarer Klickbereich über dem ganzen Siegel
            const hit = document.createElement("div");
            hit.className = "sigillum-hit";
            hit.style.position = "absolute";
            hit.style.left = cx + "px";
            hit.style.top = cy + "px";

            // Durchmesser des Klickbereichs (leicht großzügig)
            const diameter = Math.min(vw, vh) * 0.55 * scale;
            hit.style.width = diameter + "px";
            hit.style.height = diameter + "px";

            hit.style.transform = "translate(-50%, -50%)";
            hit.style.borderRadius = "50%";
            hit.style.background = "transparent";
            hit.style.zIndex = "3";
            hit.style.cursor = "pointer";

            layer.appendChild(hit);

            // Gleiche Aktion wie Cerberus & Slot-Machine
            attachCodexTrigger(hit);
          });
        }

        // Sprites: Cerberus + Slotmachine
        if (Array.isArray(config.sprites)) {
          const anchors = [
            { x: vw * 0.18, y: vh * 0.30 }, // oben links
            { x: vw * 0.82, y: vh * 0.30 }, // oben rechts
            { x: vw * 0.20, y: vh * 0.83 }, // unten links
            { x: vw * 0.80, y: vh * 0.83 }  // unten rechts
          ];
          const shuffledAnchors = shuffle(anchors);

          config.sprites.forEach((spriteCfg, idx) => {
            const sprite = document.createElement("img");
            sprite.className = "codex-image sprite";
            sprite.src = spriteCfg.src;
            sprite.alt = spriteCfg.id || "sprite";

            // Slotmachine bekommt zusätzliche Klasse
            if (spriteCfg.id === "slotmachine") {
              sprite.classList.add("slotmachine");
            }

            layer.appendChild(sprite);

            sprite.addEventListener("load", () => {
              const a = shuffledAnchors[idx % shuffledAnchors.length];
              const jitterX = randBetween(-vw * 0.03, vw * 0.03);
              const jitterY = randBetween(-vh * 0.03, vh * 0.03);

              const scale = randBetween(spriteCfg.minScale, spriteCfg.maxScale);
              const rotation = randBetween(spriteCfg.minRotation, spriteCfg.maxRotation);

              const x = a.x + jitterX;
              const y = a.y + jitterY;

              sprite.style.left = x + "px";
              sprite.style.top = y + "px";
              sprite.style.transform =
                "translate(-50%, -50%) scale(" + scale + ") rotate(" + rotation + "deg)";

              // Interaktion:
              // Slotmachine + Cerberus als Trigger
              if (spriteCfg.id === "slotmachine" || spriteCfg.id === "cerberus") {
                attachCodexTrigger(sprite);
              }
            });
          });
        }

        // Knoten: auf Kreis, Reihenfolge per Reload zufällig, NICHT gedreht
        if (Array.isArray(config.nodes)) {
          const n = config.nodes.length;
          const baseAngles = [];
          for (let i = 0; i < n; i++) {
            baseAngles.push((2 * Math.PI * i) / n);
          }
          const phase = randBetween(0, 2 * Math.PI);
          const perm = shuffle(config.nodes.map((_, i) => i));

          config.nodes.forEach((nodeCfg, idx) => {
            const nodeEl = document.createElement("div");
            nodeEl.className = "codex-node";

            const strong = document.createElement("strong");
            strong.textContent = nodeCfg.label || ("NODE-" + idx);
            nodeEl.appendChild(strong);

            if (nodeCfg.text) {
              const span = document.createElement("span");
              span.textContent = nodeCfg.text;
              nodeEl.appendChild(span);
            }

            layer.appendChild(nodeEl);

            const angleIndex = perm[idx];
            const angle = baseAngles[angleIndex] + phase;
            const radiusJitter = r * randBetween(0.96, 1.06);

            const x = cx + radiusJitter * Math.cos(angle);
            const y = cy + radiusJitter * Math.sin(angle);

            nodeEl.style.left = x + "px";
            nodeEl.style.top = y + "px";
            nodeEl.style.transform = "translate(-50%, -50%)";
          });
        }
      }

      // Initiales Rendering
      renderOnce();
    })();
  </script>
</body>

</html>
